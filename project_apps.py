# -*- coding: utf-8 -*-
"""Project Apps.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19nkXuXrixLksxX2f8YcdXbryxzVHt1i4

# Project Apps

The goal of this project is to find the most profitable within free to  download and install apps. The number of users of our apps determines our revenue for any given app â€” the more users who see and engage with the ads, the better. All data comes from The Google Play Store: 
(https://www.kaggle.com/lava18/google-play-store-apps) 
and The App Store:
(https://www.kaggle.com/ramamet4/app-store-apple-data-set-10k-apps)

Importing databases
"""

!wget https://dq-content.s3.amazonaws.com/350/googleplaystore.csv -O google_wget.csv
!wget https://dq-content.s3.amazonaws.com/350/AppleStore.csv -O apple_wget.csv

"""Loading data"""

from csv import reader
android = list(reader(open('google_wget.csv')))
android_header = android[0]
android = android[1:]
ios = list(reader(open('apple_wget.csv')))
ios_header = ios[0]
ios = ios[1:]

"""Creating function (explore_data) that prints specific rows in our data 
(that we want to explore) and total number of rows and columns
"""

def explore_data(dataset, start, end, rows_and_columns=False):
  dataset_slice = dataset[start:end]
  for row in dataset_slice:
    print(row)
    print('\n') # adds a new (empty) line after each row

  if rows_and_columns:
    print('Number  of rows:', len(dataset))
    print('Number of columns:', len(dataset[0]))

"""Printing first 5 rows in ours dataset"""

explore_data(ios, 0, 5, True)

""" The same function but in package 'Pandas'. Data is much clearer to explore."""

def explore_data_pandas(aaa, start, end):
  print(f'Number of rows: {len(aaa)}')
  print(f'Number of columns: {len(aaa[0])}')
  import pandas
  df = pandas.DataFrame(aaa[start:end])
  display(df)

explore_data_pandas(ios, 0, 5)

explore_data_pandas(android,0,5)

"""Finding incorrect rows (missing value in 'Category' column"""

print(android[10472])

"""Deleting this specific row"""

for i, row in enumerate(android):
    if row[0] == 'Life Made WI-Fi Touchscreen Photo Frame':
        del android[i]
        break

print(android[10472])

"""Creating a function that shows us how many unique apps we have"""

def unique_apps(data):
  unique_apps=[]
  duplicate_app = []

  if data == android:
    for row in data:
      app_id = row[0]

      if app_id not in unique_apps:
        unique_apps.append(app_id)
      else:
        duplicate_app.append(app_id)

  elif data == ios:
    for row in data:
      app_id = row[1]

      if app_id  not in unique_apps:
        unique_apps.append(app_id)
      else:
        duplicate_app.append(app_id)

  print('Number of unqie apps: ' + ' ' + str(len(unique_apps)))
  print('Number of duplicate apps' + ' ' + str(len(duplicate_app)))

unique_apps(android)

unique_apps(ios)

"""Creating a function which stores dictionaries with the highest numbers of reviews for each app"""

def reviews(data):
  def convert_str_to_float(string):
    if string[-1] == 'M':
        return float(string[:-1]) * 1000000
    else:
        return float(string)


  if data == android:
    rev_dict = {}
    for row in android:
        app_id = row[0]
        n_rev = convert_str_to_float(row[3])
    
        if app_id in rev_dict and rev_dict[app_id] < n_rev:
            rev_dict[app_id] = n_rev
        elif app_id not in rev_dict:
            rev_dict[app_id] = n_rev

    return rev_dict

  elif data == ios:
    rev_dict = {}
    for row in ios:
      app_id = row[1]
      n_rev = convert_str_to_float(row[5])
    
      if app_id in rev_dict and rev_dict[app_id] < n_rev:
        rev_dict[app_id] = n_rev
      elif app_id not in rev_dict:
        rev_dict[app_id] = n_rev

    return rev_dict

"""Variabies with reviews for android and ios"""

import pandas as pd

android_rev_dict = reviews(android)
ios_rev_dict  = reviews(ios)

android_rev_dict_pandas = pd.DataFrame(list(android_rev_dict.items()), columns=['App', 'n_rev'])
ios_rev_dict_pandas = pd.DataFrame(list(ios_rev_dict.items()), columns=['App', 'n_rev'])

print(android_rev_dict_pandas)

print(ios_rev_dict_pandas)

"""Creating a function that makes a data of uniqe apps"""

def make_unique(data):
  def convert_str_to_float(string):
    if string[-1] == 'M':
        return float(string[:-1]) * 1000000
    else:
        return float(string)

  if data == android:
    android_unique = []
    android_already_added = []

    for row in android:
      app_id = row[0]
      n_rev = convert_str_to_float(row[3])

      if (android_rev_dict[app_id] == n_rev) and (app_id not in android_already_added):
        android_unique.append(row)
        android_already_added.append(app_id)
    return android_unique

  elif data == ios:
    ios_unique = []
    ios_already_added = []

    for row in ios:
      app_id = row[1]
      n_rev = convert_str_to_float(row[5])

      if (ios_rev_dict[app_id] == n_rev) and (app_id not in ios_already_added):
        ios_unique.append(row)
        ios_already_added.append(app_id)
    return ios_unique

android_unique= make_unique(android)
ios_unique =make_unique(ios)

explore_data_pandas(android_unique,0,3)

explore_data_pandas(ios_unique,0,3)

"""Function that checks whether the word has no more than 3 non-English letters or signs (therfore if the App is for English users)"""

def is_english(name):
  non_ascii = 0
  for i in name:
    if ord(i) > 127:
      non_ascii += 1

  if non_ascii > 3:
    return False
  else:
    return True

"""Function that creates data with apps for english users only"""

def only_english(data):
  if data == android_unique:
    android_english = []

    for row in android_unique:
      app_name = row[0]
      if is_english(app_name):
        android_english.append(row)
    return android_english

  elif data == ios_unique:
    ios_english = []

    for row in ios_unique:
      app_name = row[1]
      if is_english(app_name):
        ios_english.append(row)
    return ios_english

android_english = only_english(android_unique)
ios_english = only_english(ios_unique)

explore_data_pandas(ios_english, 0, 3)
print(ios_header)

"""Function that creates data with free-apps only"""

def free_apps(data):
  if data == android_english:
    android_free = []

    for row in data:
      app_price = row[7]
      if app_price == '0':
        android_free.append(row)
    return android_free

  elif data == ios_english:
    ios_free = []

    for row in data:
      app_price = row[4]

      if app_price == '0.0':
        ios_free.append(row)
    return ios_free

android_free = free_apps(android_english)
ios_free = free_apps(ios_english)

explore_data_pandas(ios_free, 0, 3)

"""Our goal is to determine the kinds of apps that are likely to attract more users because the number of people using our apps affect our revenue.

To minimize risks and overhead, our validation strategy for an app idea has three steps:

Build a minimal Android version of the app, and add it to Google Play.
If the app has a good response from users, we develop it further.
If the app is profitable after six months, we build an iOS version of the app and add it to the App Store.
Because our end goal is to add the app on both Google Play and the App Store, we need to find app profiles that are successful in both markets. For instance, a profile that works well for both markets might be a productivity app that makes use of gamification.

Function that creates freq tables for any column we want
"""

def freq_table(data, index):
  table = {}
  total = 0

  for row in data:
    column = row[index]
    total += 1
    if column in table:
      table[column] += 1
    else:
      table[column] = 1

  table_perc = {}

  for i in table:
    perc = (table[i]/total) * 100
    table_perc[i] = perc

  return table_perc

"""Function that sorts freq table """

def display_table(data, index):
  table = freq_table(data, index)
  table_display = []

  for i in table:
    as_tuple = (table[i], i)
    table_display.append(as_tuple)

  table_sorted = sorted(table_display, reverse=True)
  for entry in table_sorted:
    print(entry[1], ':', entry [0])

print(ios_header)

Android_Genres = display_table(android_free, 9)

Ios_Genres = display_table(ios_free, -5)

"""Function that calculates and displays the average number of user ratings for each iOS app genre in the ios_free dataset."""

Ios_Freq_Genre = freq_table(ios_free, -5)
for row in Ios_Freq_Genre:
  total = 0
  len_genre = 0

  for app in ios_free:
    genre_app = app[-5]
    if genre_app == row:
      n_ratings = float(app[5])
      total += n_ratings
      len_genre += 1
  avg_n_ratings = total/ len_genre
  print(row, ':', avg_n_ratings)

for app in ios_free:
  if app[-5] == 'Navigation':
    print(app[1], ':', app[5])

for app in ios_free:
    if app[-5] == 'Reference':
        print(app[1], ':', app[5])

"""Function that counts averge number of installation in category"""

freq_android = freq_table(android_free,1)
for row in freq_android:
  total = 0
  len_category = 0

  for app in android_free:
    category_app = app[1]
    if category_app == row:
      n_installs = app[5]
      n_installs = n_installs.replace('+','')
      n_installs = n_installs.replace(',','')
      total += float(n_installs)
      len_category += 1
  avg_n_installs = total / len_category
  print(row, ':', avg_n_installs)

for app in android_free:
    if app[1] == 'COMMUNICATION' and (app[5] == '1,000,000,000+'
                                      or app[5] == '500,000,000+'
                                      or app[5] == '100,000,000+'):
        print(app[0], ':', app[5])